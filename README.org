#+TITLE: The bare minimal ECM service

#+begin_quote
Stop thinking like a hacker! --vyzo
#+end_quote

Being a hacker is not a bad thing and products need to come to
fruition and become solid. Those two can conflict or be best friends.

This repository is the meeting place. No hacks can exit but hacking is
more than welcome.

* Installation

For a non-github user: 

#+begin_src sh
  git clone https://github.com/Aufin/ecm-minimal.git
#+end_src

And for a dev:

#+begin_src sh
  git clone git@github.com:Aufin/ecm-minimal.git
#+end_src

** =Make='ing

#+begin_src makefile-gmake :tangle ./Makefile
  podman := podman
  local_tag := ecm:latest
  hub_tag := docker.io/aufin/ecm:latest
  run_tag := $(local_tag)
  yaml_name := ecm-app-deployment.yaml


  build:
  	$(podman) build -t $(local_tag) .

  run:
  	$(podman) run -ti --add-host=ecm-cluster-rw:host-gateway -p "0.0.0.0:8443:443" $(run_tag)

  push:
  	$(podman) push $(local_tag) $(hub_tag)

  yaml:
  	$(podman) pod create --replace --name ecm-app 
  	$(podman) create --pod ecm-app --name ecm-appd --replace docker.io/aufin/ecm:latest
  	$(podman) kube generate --type deployment --replicas 2 -f $(yaml_name) ecm-app

#+end_src


* The Pod and Container

We create a Podman pod that publishes the port, then add a container for the image. 

#+begin_src sh
  podman pod create --replace --name ecm-app --publish 8443:443
  podman create --pod ecm-app --name ecm-appd --replace docker.io/aufin/ecm:latest
#+end_src

Then the .yaml!

#+begin_src sh
  podman kube generate --type deployment --replicas 2 ecm-app
#+end_src

* The Service

With a minikube running the deployment we can generate a service.

#+begin_src sh
  kubectl expose deployment/ecm-app-deployment
#+end_src

That creates this.

#+begin_src yaml
  apiVersion: v1
  kind: Service
  metadata:
    creationTimestamp: "2025-10-09T23:48:24Z"
    labels:
      app: ecm-app
    name: ecm-app-deployment
    namespace: default
    resourceVersion: "151498"
    uid: b4ffdc10-21a4-4cd4-ad51-bee80f2ca147
  spec:
    clusterIP: 10.102.23.31
    clusterIPs:
    - 10.102.23.31
    internalTrafficPolicy: Cluster
    ipFamilies:
    - IPv4
    ipFamilyPolicy: SingleStack
    ports:
    - port: 443
      protocol: TCP
      targetPort: 443
    selector:
      app: ecm-app
    sessionAffinity: None
    type: ClusterIP
  status:
    loadBalancer: {}
#+end_src
* The Application Containerfile

Wow! Minimalism made this a lot easier.

Gerbil comes first. 

#+begin_src dockerfile :tangle Containerfile
  ARG build_cores=4
  ARG gerbil_branch=ecm-dev

  # The base distro. Alpine!
  FROM alpine:3 as base
  RUN apk update && apk add autoconf \
  	automake \
  	cmake \
  	curl \
  	g++ \
  	gcc \
  	git \
  	libgcc \
  	libsecp256k1-dev \
  	libtool \
  	libxml2-dev \
  	libxml2-static \
  	linux-headers \
  	make \
  	musl \
  	musl-dev \
  	nodejs \
  	openssl-dev \
  	openssl-libs-static \
  	ruby \
  	sqlite-dev \
  	sqlite-static \
  	xz-static \
  	yaml-dev \
  	yaml-static \
  	zlib-static

  # Now the lisp app + detachtty
  FROM base as lisp
  RUN apk add sudo sbcl
  COPY <<EOF  /root/.sbclrc
  ;;; The following lines added by ql:add-to-init-file:
  #-quicklisp
  (let ((quicklisp-init (merge-pathnames "quicklisp/setup.lisp"
                                         "/srv/ecm/lisp/")))
    (when (probe-file quicklisp-init)
      (load quicklisp-init)))
  EOF
  # RUN cat /root/.sbclrc
  COPY ecm/lisp/ /srv/ecm/lisp
  RUN cd /tmp && git clone https://github.com/cosmos72/detachtty.git && \
  	cd detachtty &&   \
  	make &&      \
  	make install && cd .. && rm -rf detachtty

  RUN cd /tmp && /srv/ecm/lisp/old-maxclaims/maxclaims/ecm/make.sh && \
   mv ecm-application /usr/local/bin
  RUN ln -s /srv/ecm/etc/ecm /root/.ecm
  EXPOSE 4242/tcp
  EXPOSE 4005/tcp


  # Install Gerbil Scheme
  FROM base as gerbil
  ARG gerbil_branch
  ARG build_cores
  ENV GERBIL_BUILD_CORES=$build_cores
  RUN echo "Building gerbil ${gerbil_branch} on ${build_cores} cores"
  RUN cd /tmp && git clone "https://github.com/mighty-gerbils/gerbil.git" \
  	&& cd gerbil && git checkout ${gerbil_branch} && ./configure --prefix=/opt/gerbil
  RUN cd /tmp/gerbil && make -j${build_cores}
  RUN cd /tmp/gerbil && mkdir -p /opt && make install
  RUN rm -rf /tmp/gerbil

  FROM base as caddyshack
  RUN apk update && apk add caddy

  FROM caddyshack AS ecm-appd
  COPY --from=gerbil /opt/gerbil /opt/gerbil
  COPY --from=lisp /usr/local/bin/ecm-application /usr/local/bin
  COPY --from=lisp /usr/local/bin/detachtty /usr/local/bin
  COPY --from=lisp /usr/local/bin/attachtty /usr/local/bin
  COPY --from=lisp /root/.sbclrc /root/.sbclrc

  RUN apk add nss-tools jq rlwrap openssh openrc

  RUN rc-update add sshd

  COPY ecm /srv/ecm
  # RUN ls /srv


  RUN mkdir -p /srv/ecm/var/log/ecm-lisp
  RUN mkdir -p /srv/ecm/var/log/ecm-appd

  RUN ln -s /srv/ecm/app/bin/ecm-appd.sh /usr/local/bin/ecm-appd
  RUN ln -s /srv/ecm/etc/ecm /root/.ecm

  RUN ls -l /root/.ecm

  ## ** Rebuild the app
  ENV GERBIL_PATH="/srv/ecm/app/.gerbil"
  ENV PATH=/opt/gerbil/bin:"${PATH}"
  RUN cd /srv/ecm/app && ./build.ss

  EXPOSE 80/tcp
  EXPOSE 443/tcp
  EXPOSE 8080/tcp
  EXPOSE 4242/tcp
  EXPOSE 4005/tcp

  WORKDIR /srv/ecm
  CMD ecm-appd






#+end_src
